# PARSING_RULES_ADVANCED.md - 高度なパターン

**Version**: 2.0  
**Status**: 仕様確定 ✅  
**Last Updated**: 2025-12-14  
**分割元**: PARSING_RULES.md（行3325〜4483）

---

このドキュメントは、城プロREのテキストパース仕様のうち、パターン11以降の高度なパターンを扱います。

**関連ドキュメント**:
- [PARSING_RULES.md](./PARSING_RULES.md) - コア仕様（パターン1〜10）
- [WIKI_PARSER_GUIDE.md](./WIKI_PARSER_GUIDE.md) - Wikiパーサー実装知見とバージョン履歴

---

### パターン11: 爆風範囲・爆風ダメージ

ダメージ計算では無視してよいが、存在は認識すべきパターンです。

```typescript
// 例: 爆風範囲と爆風ダメージ2倍
```

**処理方法**: 備考（note）として記録し、パースはスキップ

### パターン12: 射程内と射程外で効果が異なるバフ

同じステータスに対して、範囲によって異なる値のバフが提供される場合があります。これは甲府城の特技に見られるパターンです。

```typescript
// 例: 射程内の味方の射程10、攻撃速度7%与ダメ7%上昇、攻撃後の隙7%短縮。
//     射程外の味方は射程8、攻撃速度6%、与ダメ6%上昇、攻撃後の隙6%短縮
```

**重要な設計決定**: バフパズルでは射程内の大きな効果を参照し、射程外の効果は備考として扱います。

**理由**: 同種バフは最大値が適用される（パーセント系）、または加算される（固定値）ため、バフパズルでは最大ポテンシャルを表示することが目的です。射程外の小さい値は、詳細情報として別途表示します。

**処理方法**: 両方のバフを生成しますが、UIでは射程内のバフを優先的に表示します。

```typescript
// 射程内のバフ（優先表示）
{
  stat: 'attack_speed',
  target: 'range/ally',
  value: 35,  // 7% × 5（巨大化倍率）
  source: 'self_skill',
  priority: 'high'  // ★新しいフィールド
}

// 射程外のバフ（備考）
{
  stat: 'attack_speed',
  target: 'out_of_range/ally',  // ★新しいターゲット
  value: 30,  // 6% × 5
  source: 'self_skill',
  priority: 'low',
  note: '射程外の城娘に適用'
}
```

### パターン13: 編成特技の除外

編成特技は初期値に関わるため、バフパズルでは表示しません。

```typescript
// 例: 部隊の[絢爛]と関東・甲信越城娘の初回計略使用までの時間が30%
//     計略再使用までの時間が5%短縮
```

**処理方法**: `source: 'formation_skill'` のバフは生成しますが、バフパズルのUIでは表示しません。ダメージ計算時の初期値計算では使用される可能性があります。

### パターン14: ノックバックの4段階

ノックバックには強度によって4種類の表記があります。

```typescript
// 少し後退 → 1マス
// 後退 → 2マス
// 大きく後退 → 3マス
// 劇的に後退 → 4マス
```

**検出パターンの優先順位**:

```typescript
const KNOCKBACK_PATTERNS = [
  { pattern: /劇的に後退/, value: 4, priority: 1 },
  { pattern: /大きく後退/, value: 3, priority: 2 },
  { pattern: /(\d+)マス?後退/, value: 'numeric', priority: 3 },
  { pattern: /少し後退/, value: 1, priority: 4 },
  { pattern: /後退(?!させる)/, value: 2, priority: 5 }  // 単独の「後退」は最後
];
```

**注意**: より具体的なパターンを先にチェックする必要があります。「後退」だけの検出を先にすると、「大きく後退」も誤って「後退」とマッチしてしまいます。

### パターン15: 徐々に気が増加する系の複雑なルール

同じ「時間経過で気が徐々に増加」という文言が、文脈によって異なる意味を持ちます。これは正規表現だけでは対応できない、最も複雑なパターンの一つです。

**ルール**:

1. **基本パターン**: 「時間経過で気が徐々に増加」→ 5秒ごとに2増加
2. **明示的な指定**: 「10秒毎に気が1増加」→ 指定された通り
3. **巨大化依存**: 「巨大化する度に...時間経過で気が徐々に増加」→ 10秒ごとに5増加（最大値）

**処理フロー**:

```typescript
function parseGradualCostIncrease(text: string, context: ParseContext) {
  // ステップ1: 明示的な指定を優先
  const explicitMatch = text.match(/(\d+)秒(?:毎|ごと)に気が(\d+)増加/);
  if (explicitMatch) {
    return {
      interval: parseInt(explicitMatch[1]),
      amount: parseInt(explicitMatch[2]),
      note: '明示的な指定'
    };
  }
  
  // ステップ2: 「時間経過で気が徐々に増加」の基本パターン
  if (/時間経過で気が徐々に増加/.test(text)) {
    // 巨大化依存かどうかをチェック
    if (context.hasGiantPrefix) {
      return {
        interval: 10,
        amount: 5,  // 巨大化5段階時の最大値
        note: '巨大化依存（最大値）'
      };
    } else {
      return {
        interval: 5,
        amount: 2,
        note: '基本パターン'
      };
    }
  }
  
  return null;
}
```

**重要な注意**: このルールは現時点で発見されたパターンに基づいています。今後、例外が見つかる可能性があります。

**★v2.0 実装知見 - 徐々気パターンの厳格化**:

緩いパターン `/時間経過で.*?気(?:が)?.*?(\d+)/` は誤検知を招きます。例えば「時間経過でも蓄積...獲得気が2」のような無関係なテキストにもマッチしてしまいます。

**推奨される厳格パターン**:
```typescript
// NG: 緩すぎる（誤検知多発）
/時間経過で.*?気(?:が)?.*?(\d+)/

// OK: 「気が」が「時間経過で」の直後にある必要がある
/時間経過で気が(?:徐々に)?(\d+)(?:増加|回復)/
```

徐々気は `stat: 'cost_gradual'` として分離管理されます。

### パターン16: 自然増加量の「増加」と「大きく増加」

気の自然増加量には、副詞による値の修飾があります。

```typescript
// 気の自然増加量を増加 → +40%
// 気の自然増加量を大きく増加 → +70%
```

**検出パターン**:

```typescript
const NATURAL_COST_PATTERN = /気の自然増加量を(大きく)?増加/;

const MAGNITUDE_VALUES = {
  '': 40,        // 修飾なし
  '大きく': 70   // 「大きく」修飾
};

// 使用例
const match = text.match(NATURAL_COST_PATTERN);
if (match) {
  const magnitude = match[1] || '';
  const value = MAGNITUDE_VALUES[magnitude];

  return {
    stat: 'cost',  // ★v2.0: costTypeは廃止、自然気はstat: 'cost'
    mode: 'percent_max',
    value: value
  };
}
```

### パターン17: (重複時効果減少) - スタックペナルティ

これは「効果重複」とは異なる新しい概念です。同じバフが複数スタックした場合、2つ目以降の効果が減少します。

```typescript
// 例: 気の自然増加量を大きく増加(重複時効果減少)
```

**意味**: 同じキャラを2体編成した場合、2体目の効果が半減します。

- 1体目: +70%
- 2体目: +35%（半減）
- 合計: +105%

**新しいフィールド**:

```typescript
interface Buff {
  // ... 既存のフィールド
  stackPenalty?: number;  // スタック時のペナルティ（0.5 = 半減）
}
```

**検出パターン**:

```typescript
if (/重複時効果減少/.test(text)) {
  buff.stackPenalty = 0.5;
}
```

### パターン18: (重複なし) - 最大値のみ適用

これは「複数のキャラが同じstatのバフを持っている場合、最大値のものだけが適用される」という意味です。

```typescript
// 例1: 射程内敵の撃破気1増加(重複なし)
// 例2: 射程内敵の撃破獲得気2増加
```

両方が編成にいる場合、値が大きい方（+2）だけが適用され、小さい方（+1）は無効になります。

**新しいフィールド**:

```typescript
interface Buff {
  // ... 既存のフィールド
  nonStacking?: boolean;  // 重複しない（最大値のみ適用）
}
```

**検出パターン**:

```typescript
if (/重複なし/.test(text)) {
  buff.nonStacking = true;
}
```

**UI表示**: このフラグがあるバフは、「重複なし」というバッジを表示し、ユーザーに警告します。

### パターン19: 対象が暗黙的な複雑な文章構造

一部のキャラクター（特に伏兵を召喚するキャラ）の特技は、対象が明示的に書かれていない複雑な構造を持ちます。

```typescript
// 例: 飛行敵以外に狙われず攻撃しない伏兵(1体)。
//     時間経過で射程が徐々に上昇(上限200)。
//     気の自然増加量を大きく増加(重複時効果減少)。
//     射程内敵の撃破気1増加(重複なし)
```

**対象の推測ルール**:

1. 文の最初に「伏兵」というキーワードがある場合、その段落の効果は伏兵に関するものと推測
2. ただし、「気の増加」系は常にフィールド全体への効果なので、`target: 'field'`
3. 「射程内敵」というキーワードがある場合、それは伏兵の射程内を指している可能性が高い

**処理の難しさ**: これは正規表現だけでは完全には対応できません。実装時には、キーワードとヒューリスティックなルールの組み合わせが必要になります。

**暫定的な処理方針**: 

- 明確に判定できない場合は、`note`フィールドに元のテキストを保存
- ユーザーに「この効果の対象は推測です」と警告を表示
- 将来的に、より多くの例を集めてパターンを改善

### パターン21: 動的バフ - 可変パラメータに依存する効果

**極めて重要な概念**: 気は個別のキャラクターが持つリソースではなく、編成全体で共有されるフィールドリソースです。この理解は、気に関するバフの処理において根本的に重要です。

#### 気のゲームシステム

城プロREにおいて、気は以下のように機能します。

まず、気は時間経過で自然に増加していきます。これが基本的な気の獲得方法です。プレイヤーはこの共有された気を使って、城娘を配置したり、巨大化させたり、計略を発動したり、特殊能力を使用したりします。つまり、気は編成全体で管理される行動ポイントのようなリソースです。

気に関するバフには、以下のような種類があります。

- **気の自然増加量を上昇**: フィールド全体での気の増加速度が上がる
- **敵撃破時の気獲得を増加**: 敵を倒したときにフィールド全体の気が増える（気(牛)）
- **巨大化気を軽減**: 巨大化に必要な気の消費量が減る
- **計略消費気を軽減**: 計略発動に必要な気の消費量が減る

これら全ての効果は、特定のキャラクターに影響するのではなく、フィールド全体に影響します。

#### 処理ルール（v2.0改訂）

気に関するバフは、**分離したStat**で管理します。`costType` フィールドは廃止され、代わりにStatそのもので気の種類を区別します。

**気関連のStat一覧**:
- `cost` - 自然気増加（自然に気が増加/大きく増加）
- `cost_gradual` - 徐々気（時間経過で徐々に気が増加）
- `cost_giant` - 巨大化気軽減（巨大化消費気の軽減）
- `cost_enemy_defeat` - 気(牛)（敵撃破時の獲得気）
- `cost_defeat_bonus` - 気(ノビ)（味方/城娘の撃破気ボーナス）
- `cost_strategy` - 計略消費気（計略の消費気軽減）

```typescript
// 例1: 気の自然増加量を大きく増加
{
  stat: 'cost',           // ★分離Statで種類を区別
  mode: 'percent_max',
  value: 70,              // 大きく増加 = 70%
  note: 'フィールド全体の気の増加速度に影響'
}

// 例2: 敵撃破時の獲得気2増加（気(牛)）
{
  stat: 'cost_enemy_defeat',  // ★敵撃破時は専用Stat
  mode: 'flat_sum',
  value: 2,
  note: '敵撃破時、フィールド全体の気が増加'
}

// 例3: 巨大化気を半減
{
  stat: 'cost_giant',     // ★巨大化気は専用Stat
  mode: 'percent_reduction',
  value: 50,
  note: '巨大化の消費気が軽減される'
}

// 例4: 時間経過で気が徐々に増加（徐々気）
{
  stat: 'cost_gradual',   // ★徐々気は専用Stat
  mode: 'flat_sum',
  value: 2,
  note: '5秒毎に2増加'
}
```

#### 伏兵と気の関係

伏兵を召喚するキャラクター（鹿野城など）の特技は、気の処理において特に重要な例です。

鹿野城が伏兵を召喚すると、その伏兵は攻撃をしませんが、フィールドに存在し続けます。そして、その伏兵の射程内の敵が倒されると、フィールド全体の気が増加します。

これは「伏兵が気を得る」のではなく、「伏兵の存在がフィールド全体の気の増加に貢献する」という意味です。伏兵は気の増加装置として機能しており、伏兵自身が気を使うことも、気を保持することもありません。

```typescript
// 鹿野城の例: 「射程内敵の撃破気1増加(重複なし)」
{
  stat: 'cost_enemy_defeat',  // ★v2.0: 分離Statを使用
  mode: 'flat_sum',
  value: 1,
  nonStacking: true,
  note: '伏兵の射程内の敵撃破時、フィールド全体の気が+1される',
  source: 'self_skill'  // 鹿野城の特技による効果
}
```

この効果は伏兵自身に紐づくものではなく、鹿野城が配置されることによってフィールド全体に与えられる効果です。伏兵が召喚されたときに、このバフが有効になり、フィールドレベルで気の増加に貢献します。

#### バフパズルでの気の表示

バフパズルにおいて、気のバフは他のバフとは異なる扱いが必要です。気はフィールド全体で共有されるため、「誰が誰に気のバフを与える」という表現は適切ではありません。

より正確には、「この編成では、気の増加速度がどれだけ上がるか」「敵撃破時の気の獲得量がどれだけ増えるか」という情報を表示すべきです。これは、個別のキャラクターへのバフではなく、編成全体のリソース管理に関する情報になります。

**UI設計の推奨**:

バフマトリクスとは別に、「フィールド効果」のようなセクションを設けて、気に関するバフをまとめて表示するのが良いでしょう。例えば：

**フィールド効果**
- 気の自然増加速度: +70%（鹿野城による）
- 敵撃破時の気獲得: +1（鹿野城の伏兵による、重複なし）
- 巨大化気軽減: -50%（ゴールデン・ハインド、水上配置時のみ）

このように、編成全体での気の管理状況が一目で分かる表示が理想的です。

### パターン21: 動的バフ - 可変パラメータに依存する効果

**極めて重要な概念**: 一部のバフは、戦闘中に変動するパラメータ（敵の数、伏兵の数、味方の数など）に依存して効果が変化します。これらを「動的バフ」と呼びます。動的バフは、バフパズルとダメージ計算で異なる扱いが必要になります。

#### 動的バフの分類

動的バフは、依存するパラメータの性質によって2つのカテゴリに分類されます。この分類は、ツールでの扱い方を決定する上で重要です。

**カテゴリA: 編成依存の動的バフ**

編成構築時にある程度コントロール可能なパラメータに依存するバフです。具体的には、伏兵の数や味方の数などがこれに該当します。これらは編成を確定した時点で、想定される値の範囲を絞り込むことができます。

例として、ドレッドノートの計略を見てみましょう。「40秒間対象の射程が1.5倍、射程内の対象を除く味方1体につき攻撃が150、与えるダメージが15%ずつ上昇」というバフがあります。このバフの効果は、射程内にいる味方の数によって変化します。しかし、編成は8人と決まっているため、「最大で味方7人分、つまり攻撃+1050、与ダメ+105%」という上限が明確に存在します。

編成依存の動的バフは、編成構築のシミュレーションである程度具体的な値を計算できるため、バフパズルでも部分的に扱うことができます。ただし、実際の配置や射程の関係で、理論上の最大値と実際の値は異なる可能性があります。

**カテゴリB: 戦闘状況依存の動的バフ**

戦闘中に刻一刻と変化し、プレイヤーがコントロールできないパラメータに依存するバフです。具体的には、敵の数がこれに該当します。敵は出現し、倒され、また新たに出現するため、バフの効果は常に変動します。

例として、ある城娘の特技「最大化時、射程内敵1体毎に防御が12%ずつ上昇(効果重複)」を考えてみましょう。このバフの効果は、射程内にいる敵の数によって変化します。しかし、敵の数は戦闘のフェーズによって大きく変動するため、具体的な値を予測することが困難です。

戦闘状況依存の動的バフは、シナリオを想定しない限り具体的な値を出せません。そのため、バフパズルでは原則として除外し、ダメージ計算でシナリオごとに分析する必要があります。

#### 動的バフの検出パターン

動的バフは、以下のようなキーワードで検出できます。

```typescript
const DYNAMIC_BUFF_PATTERNS = [
  {
    pattern: /射程内(?:の)?敵(\d+)体(?:毎|ごと)に/,
    type: 'per_enemy_in_range',
    category: 'combat_situation'
  },
  {
    pattern: /射程内(?:の)?(?:対象を除く)?味方(\d+)体(?:毎|ごと|につき)に?/,
    type: 'per_ally_in_range',
    category: 'formation'
  },
  {
    pattern: /伏兵(\d+)体(?:毎|ごと)に/,
    type: 'per_ambush_deployed',
    category: 'formation'
  },
  {
    pattern: /撃破(?:した)?敵(\d+)体(?:毎|ごと)に/,
    type: 'per_enemy_defeated',
    category: 'combat_situation'
  },
  {
    pattern: /(?:自身を除く)?編成内(?:の)?(.+?)(\d+)体(?:毎|ごと)に/,
    type: 'per_specific_in_formation',
    category: 'formation'
  }
];
```

#### 動的バフの型定義

動的バフを表現するため、Buffインターフェースに新しいフィールドを追加します。

```typescript
interface Buff {
  // ... 既存のフィールド
  
  // 動的バフ関連
  isDynamic?: boolean;                    // 動的バフかどうか
  dynamicType?: DynamicBuffType;          // 動的バフの種類
  dynamicCategory?: 'formation' | 'combat_situation';  // カテゴリ
  unitValue?: number;                     // 単位あたりの効果値
  dynamicParameter?: string;              // 動的パラメータの説明
}

type DynamicBuffType = 
  | 'per_enemy_in_range'        // 射程内敵1体毎
  | 'per_ally_in_range'         // 射程内味方1体毎
  | 'per_ally_other'            // 自身を除く味方1体毎
  | 'per_ambush_deployed'       // 配置された伏兵1体毎
  | 'per_enemy_defeated'        // 撃破した敵1体毎
  | 'per_specific_attribute'    // 特定属性の城娘1体毎
  | 'per_specific_weapon';      // 特定武器種の城娘1体毎
```

#### 動的バフの生成例

「射程内敵1体毎に防御が12%ずつ上昇(効果重複)」というテキストから、以下のようなバフを生成します。

```typescript
{
  id: 'buff-dynamic-001',
  stat: 'defense',
  target: 'self',
  mode: 'percent_max',
  value: 12,  // 単位値（敵1体あたり）
  isDuplicate: true,
  
  // 動的バフ専用フィールド
  isDynamic: true,
  dynamicType: 'per_enemy_in_range',
  dynamicCategory: 'combat_situation',
  unitValue: 12,
  dynamicParameter: '射程内の敵の数',
  
  note: '射程内敵1体毎に+12%（効果は敵数に依存して変動）',
  source: 'self_skill',
  conditionTags: ['giant_5'],  // 最大化時
  isActive: true
}
```

#### バフパズルにおける動的バフの扱い

**設計方針**: 動的バフは、バフパズルの主要な計算からは除外します。バフパズルの目的は、編成内の静的なバフの関係性を可視化することです。動的バフを混ぜてしまうと、この目的がぼやけてしまいます。

**UI設計**: バフマトリクスの下に「動的バフ（参考情報）」というセクションを設けます。このセクションでは、動的バフの単位効果を表示し、想定される効果の範囲を示します。

UI表示の例を見てみましょう。通常のバフマトリクスの下に、動的バフのセクションが配置されます。

```
【通常のバフマトリクス】
┌──────────────────────────────┐
│ キャラA → キャラB             │
│ 攻撃+30% (射程内)             │
└──────────────────────────────┘

【動的バフ（参考情報）】
⚠️ これらのバフの実際の効果は、戦闘中の状況によって変動します

キャラC（自身）:
  🔄 防御+12%/敵（射程内敵1体毎）
     - 敵5体想定: +60%
     - 敵10体想定: +120%
     - 最大化時のみ、効果重複

ドレッドノート（伏兵経由）:
  🔄 攻撃+120（伏兵の射程内の城娘、伏兵1体あたり）
     - 伏兵3体配置時: 最大+360
     - 実際の効果は各城娘の位置に依存
```

このように、動的バフの存在を認識しつつ、それをバフパズルの主要な計算からは除外することで、ツールの使いやすさが保たれます。ユーザーは静的なバフの最適化に集中でき、動的バフについては別途考慮できるわけです。

#### ダメージ計算における動的バフの扱い

ダメージ計算においては、動的バフは非常に重要な要素になります。ここでは、シナリオ管理機能が必要になります。

**設計方針**: 同じキャラクターでも、異なる想定（伏兵10体、15体、20体など）で複数のインスタンスを作成し、それぞれでダメージ計算を行います。

**実装の具体例**: ドレッドノートを例に考えてみましょう。ドレッドノートは伏兵を際限なく配置でき、伏兵の数によってバフの効果が大きく変動します。ダメージ計算では、以下のような操作ができるべきです。

まず、ユーザーはドレッドノートを選択し、「シナリオを追加」ボタンをクリックします。すると、動的パラメータを入力するダイアログが表示されます。ここで、「配置された伏兵の数」や「射程内の味方の数」などを設定します。

例えば、「伏兵10体シナリオ」を作成した場合、ドレッドノートの伏兵からのバフ（攻撃+120/伏兵）が、10倍の+1200として計算されます。同様に、「伏兵15体シナリオ」「伏兵20体シナリオ」を作成し、それぞれの最終攻撃力やダメージを比較できます。

これにより、ユーザーは「伏兵を何体配置するのが最も効率的か」といった実践的な疑問に答えることができます。

#### 具体例: ドレッドノート

ドレッドノートは、動的バフの最も複雑な例です。この城娘の特技と計略を詳しく見てみましょう。

**特技**:
```
自身と自身の伏兵の直撃ボーナスが120%、爆風範囲が50%上昇、被ダメ50%軽減。
射程内敵の被ダメ50%上昇
【水上】全軍船と自身の伏兵の与えるダメージが1.25倍
```

この特技には動的バフは含まれていません。全て静的なバフとして処理できます。

**計略（伏兵召喚）**:
```
自身の1.2倍の耐久/攻撃/防御で敵2体とその周囲に4連続攻撃を行う伏兵を配置(水上移動可)
伏兵の射程内の城娘の攻撃が120、射程が30上昇
```

この計略には、伏兵経由の静的バフが含まれています。ただし、伏兵は複数配置できるため、伏兵の数によって合計のバフ量が変動します。これは編成依存の動的バフと見なすことができます。

**計略（バフ）**:
```
40秒間対象の射程が1.5倍、射程内の対象を除く味方1体につき攻撃が150、与えるダメージが15%ずつ上昇
対象と自身の伏兵の攻撃が2倍(自分のみ)
```

この計略には、明確な動的バフが含まれています。「射程内の対象を除く味方1体につき」という部分が、動的パラメータです。

生成されるバフの例を見てみましょう。

```typescript
// 静的バフ: 射程1.5倍
{
  stat: 'range',
  target: 'ally',  // 対象
  mode: 'percent_max',
  value: 50,
  source: 'strategy',
  isActive: true
}

// 動的バフ: 味方1体につき攻撃+150
{
  stat: 'attack',
  target: 'ally',  // 対象
  mode: 'flat_sum',
  value: 150,  // 単位値
  isDynamic: true,
  dynamicType: 'per_ally_in_range',
  dynamicCategory: 'formation',
  unitValue: 150,
  dynamicParameter: '射程内の対象を除く味方の数',
  note: '味方1体につき+150（最大7体で+1050）',
  source: 'strategy',
  isActive: true
}

// 動的バフ: 味方1体につき与ダメ+15%
{
  stat: 'give_damage',
  target: 'ally',  // 対象
  mode: 'percent_max',
  value: 15,  // 単位値
  isDynamic: true,
  dynamicType: 'per_ally_in_range',
  dynamicCategory: 'formation',
  unitValue: 15,
  dynamicParameter: '射程内の対象を除く味方の数',
  note: '味方1体につき+15%（最大7体で+105%）',
  source: 'strategy',
  isActive: true
}
```

バフパズルでは、これらの動的バフを「参考情報」として表示します。一方、ダメージ計算では、「射程内に味方が5人いる」「7人いる」といったシナリオを作成し、それぞれのダメージを比較できます。

このように、動的バフを適切に扱うことで、ドレッドノートのような複雑なキャラクターでも、実践的な分析が可能になります。

### パターン22: 条件による値の分岐（直接指定）

以前のパターン（大坂城の「効果1.5倍」など）では、基本値に倍率を掛けるという形で条件付き効果を表現していました。しかし、一部のキャラクターでは、条件によって直接的に異なる値が指定されるパターンがあります。

```typescript
// 例: 射程内の味方の攻撃と防御と与ダメージが40%、近接城娘は50%上昇
```

**構造の分析**:

この文章には、2つのレベルの効果が含まれています。まず、基本効果として「射程内の味方」全体に対して40%の上昇があります。そして、条件付き効果として「近接城娘」に限定した場合は50%の上昇になります。

重要なのは、これは「40%の1.25倍で50%」という計算ではなく、直接的に「近接城娘には50%」と指定されているということです。つまり、近接城娘に対しては40%のバフと50%のバフの両方が生成されますが、実際の適用時には条件を満たす方（50%）が選択されます。

**パース時の処理**:

このパターンを検出するには、読点（、）で文を分割し、前後で範囲指定が変化しているかをチェックします。

```typescript
// ステップ1: 読点で分割
const segments = text.split(/、|,/);
// ["射程内の味方の攻撃と防御と与ダメージが40%", "近接城娘は50%上昇"]

// ステップ2: 各セグメントを解析
segment1: {
  target: 'range/ally',
  stats: ['attack', 'defense', 'damage_dealt'],
  value: 40,
  mode: 'percent_max'
}

segment2: {
  target: 'range/ally',  // 範囲は引き継がれる
  conditionTags: ['melee'],  // ★条件が追加
  stats: ['attack', 'defense', 'damage_dealt'],  // statsも引き継がれる
  value: 50,
  mode: 'percent_max'
}
```

**生成されるBuffの例**:

この特技からは、合計6つのBuffが生成されます。基本効果として射程内の味方全体への3つのBuff（攻撃40%、防御40%、与ダメ40%）、そして条件付き効果として射程内の近接城娘への3つのBuff（攻撃50%、防御50%、与ダメ50%）が生成されます。

```typescript
// 基本効果（射程内の味方全体）
[
  {
    stat: 'attack',
    target: 'range/ally',
    mode: 'percent_max',
    value: 40,
    conditionTags: [],
    priority: 'normal',
    source: 'self_skill'
  },
  // defense, damage_dealt も同様...
  
  // 条件付き効果（射程内の近接城娘）
  {
    stat: 'attack',
    target: 'range/ally',
    mode: 'percent_max',
    value: 50,
    conditionTags: ['melee'],  // ★近接のみ
    priority: 'high',  // ★条件付きバフの方が優先度が高い
    source: 'self_skill'
  },
  // defense, damage_dealt も同様...
]
```

**バフ適用時の処理**:

バフ適用判定時には、同じstatに対して複数のバフがある場合、条件を満たすバフの中から最大値を選びます。近接城娘の場合は`melee`条件を満たすバフ（50%）が適用され、遠隔城娘の場合は条件なしのバフ（40%）が適用されます。

**重要な設計決定**: 近接・遠隔はConditionTagで処理する

武器種別条件（近接・遠隔）はConditionTagとして扱うことに決定しました。この理由は、属性条件（水、平、山など）と武器種別条件は、ゲームシステム上は同じレベルの「絞り込み条件」だからです。どちらも編成メンバーの中から特定の条件を満たすキャラクターを絞り込むという処理になります。

したがって、実装上も同じ仕組みで扱うのが自然です。targetは「範囲」を表現することに専念し、その範囲の中で「誰に効くか」という絞り込みはConditionTagが担当する、という責務の分離が明確になります。

```typescript
// 水属性の城娘への効果
{ target: 'range/ally', conditionTags: ['water'] }

// 近接城娘への効果
{ target: 'range/ally', conditionTags: ['melee'] }

// 近接かつ水属性の城娘への効果
{ target: 'range/ally', conditionTags: ['melee', 'water'] }
```

この一貫性は、バフ適用判定のロジックをシンプルに保つ上でも重要です。全てのConditionTagを同じループでチェックすればよく、武器種別だけ特別扱いする必要がありません。

**優先度の調整**:

武器種別条件（melee, ranged）の優先度は、属性条件と同じレベルの「中程度（優先度6）」に設定します。これにより、UI上での表示順序が自然になります。

**完全な実例**:

提示された特技全体を解析してみましょう。

```
自身の攻撃対象が3増加。
射程内の味方の攻撃と防御と与ダメージが40%、近接城娘は50%上昇。
全近接城娘の巨大化気を35%軽減。
10秒毎に気が追加で2増加
```

セグメント1は自身の攻撃対象+3、セグメント2は射程内の味方への基本バフ40%と近接城娘への条件付きバフ50%、セグメント3は全近接城娘の巨大化気軽減35%、セグメント4は10秒毎に気が追加で2増加、となります。特に注目すべきは、セグメント3の「全近接城娘の巨大化気を35%軽減」です。気はフィールド全体で共有されるリソースなので、`target: 'field'`として表現しますが、`conditionTags: ['melee']`を付けることで「近接城娘が巨大化する際に適用される軽減」という意味を表現できます。

このパターンは、条件による値の分岐を扱う上で非常に重要な実例です。基本値と条件付き値を別々のBuffとして生成し、適用時に適切な方を選択するというアプローチにより、柔軟で拡張性の高い設計が実現できます。

### パターン23: 計略範囲バフ - 範囲サイズによる分類

計略の中には、範囲を指定してその範囲内の味方にバフを与えるものがあります。この範囲のサイズによって、実際に何人の味方を巻き込めるかが大きく変わるため、バフパズルでの扱い方を範囲サイズに応じて変える必要があります。

```typescript
// 例: 30秒間範囲内の殿と城娘の攻撃と攻撃速度が1.25倍
//     攻撃後の隙が40%短縮(同種効果重複)(範囲：超特大、発動中の計略を解除しない)
```

**ゲームの実態と設計方針**:

城プロREは基本的に「射程内に味方を入れる」ゲームです。つまり、キャラクターを密集して配置し、互いにバフを掛け合うことが基本戦略になります。この前提があるため、計略の範囲バフは、範囲サイズによって以下のように分類できます。

超特大から大の範囲は、実際のプレイでは基本戦略（密集配置）を実行する限り、複数の味方を巻き込むことがほぼ確実です。これは信頼できる情報として、バフパズルの計算に含めることができます。一方、中から小の範囲は、マップの形状や配置戦略によって、巻き込める味方の数が大きく変動します。これは不確定性が高いため、保守的に扱う必要があります。

**範囲サイズによるtarget変換ルール**:

範囲サイズの表記と、それに対応するtargetの変換ルールを定義します。この変換により、バフパズルで適切な扱いができるようになります。

```typescript
const RANGE_SIZE_TO_TARGET = {
  // 超特大・特大：複数を確実に巻き込める
  '超特大': 'range',
  '特大': 'range',
  
  // 大：複数巻き込める可能性が高いが、全員ではない
  '大': 'range',
  
  // 中・小：対象指定に近い（1〜2人程度）
  '中': 'ally',
  '小': 'ally',
  
  // 特殊ケース：伏兵の射程内（後述）
  '伏兵の射程内': 'dynamic'  // 動的バフとして扱う
};
```

この分類は、実際のゲームプレイの感覚に基づいた実用的な判断です。完璧な情報ではありませんが、編成構築時の意思決定には十分な精度を持っています。

**パース時の処理フロー**:

計略範囲バフを検出する際の処理手順を示します。この手順により、範囲情報を適切にBuffオブジェクトに変換できます。

まず、括弧内の範囲情報を抽出します。正規表現パターン`/（範囲[：:]\s*(.+?)(?:[、,)]|$)/`を使って、「範囲：超特大」といった部分を検出します。次に、抽出した範囲サイズを上記の変換テーブルに照らし合わせ、適切なtargetを決定します。そして、元の範囲サイズ情報はnoteフィールドに保存します。これにより、ユーザーが後から「なぜこのtargetになったのか」を確認できます。

最後に、効果時間の情報（「30秒間」など）はバフパズルでは使用しませんが、これもnoteに保存しておきます。将来的にダメージ計算機能を拡張する際に役立つ可能性があります。

**生成されるBuffの例**:

提示された計略テキストから生成されるBuffオブジェクトを具体的に示します。

```typescript
// 「30秒間範囲内の殿と城娘の攻撃と攻撃速度が1.25倍攻撃後の隙が40%短縮
//  (同種効果重複)(範囲：超特大、発動中の計略を解除しない)」

[
  // 攻撃バフ
  {
    id: 'strategy-buff-001',
    stat: 'attack',
    target: 'range',  // 超特大なのでrange
    mode: 'percent_max',
    value: 25,  // 1.25倍 → 25%上昇
    isDuplicate: true,  // 同種効果重複
    source: 'strategy',
    note: '30秒間、範囲：超特大、発動中の計略を解除しない',
    isActive: true
  },
  
  // 攻撃速度バフ
  {
    id: 'strategy-buff-002',
    stat: 'attack_speed',
    target: 'range',
    mode: 'percent_max',
    value: 25,
    isDuplicate: true,
    source: 'strategy',
    note: '30秒間、範囲：超特大、発動中の計略を解除しない',
    isActive: true
  },
  
  // 隙短縮バフ
  {
    id: 'strategy-buff-003',
    stat: 'attack_gap',
    target: 'range',
    mode: 'percent_reduction',
    value: 40,
    isDuplicate: true,
    source: 'strategy',
    note: '30秒間、範囲：超特大、発動中の計略を解除しない',
    isActive: true
  }
]
```

各Buffオブジェクトのnoteフィールドには、元の範囲サイズ（超特大）と効果時間（30秒間）が保存されています。これにより、ユーザーはバフの詳細を確認でき、なぜrangeとして扱われているのかを理解できます。

**重要な除外情報**:

括弧内の一部の情報は、バフパズルの文脈では実質的に意味を持ちません。これらは除外するか、noteにのみ保存します。

効果時間（「30秒間」など）は、バフパズルでは「バフが発動している状態」を前提とするため、計算には使用しません。ただし、noteに保存しておくことで、将来的なダメージ計算機能で活用できる可能性があります。

「発動中の計略を解除しない」といった戦闘中の挙動に関する情報も、編成パズルのスコープ外です。これもnoteに保存するだけで十分です。

**特殊ケース：伏兵の射程内バフ**:

伏兵の射程内という表記は、通常の範囲サイズとは異なる特殊な性質を持っています。これは動的バフとして扱う必要がありますが、その理由は一般に想像されるものとは異なります。

伏兵の射程内バフが持つ不確定要素を整理してみましょう。まず、編成依存の要素として、伏兵を召喚するキャラクターを編成に入れるかどうかという選択があります。次に、配置依存の要素として、伏兵をどこに配置するかによって、射程内に入る味方が変わります。さらに、伏兵の種類による要素として、どのキャラクターの伏兵を使うかによって、提供されるバフの内容や伏兵自体の性能が大きく変わります。

ここで重要な実態を理解する必要があります。城プロREにおいて、伏兵は二つの大きなカテゴリに分類されます。一つは支援型伏兵で、これは気の自然増加や気(牛)、気(ノビ)といったフィールドレベルのリソース管理を担当します。もう一つは戦闘型伏兵で、成都城のような高い耐久力と攻撃力を持ち、前線で戦闘を支える役割を果たします。

支援型伏兵の場合、プレイヤーは気管理という編成全体の生命線を守るため、伏兵を死守する陣形を取って戦います。つまり、これらの伏兵は実際には非常に高い生存率を持ち、そのバフも信頼性が高い可能性があります。一方、戦闘型伏兵の場合、伏兵自体が前線で敵と交戦するため、配置位置や戦況によってバフの提供範囲が変動します。

この複雑な実態を踏まえると、伏兵の射程内バフを一律に「信頼性が低い」と扱うのは適切ではありません。しかし、バフパズルの設計思想である「静的な編成分析」という観点からは、伏兵の配置と種類による変動要素が大きすぎるため、動的バフとして扱うのが妥当です。

重要なのは、伏兵バフが動的である理由は生存率の低さではなく、配置の柔軟性と効果の多様性にあるということです。伏兵をどこに配置するか、どの伏兵を使うか、何体配置するかという選択によって、最終的なバフ効果が大きく変わります。この変動性こそが、伏兵バフを動的バフとして扱うべき本質的な理由なのです。

```typescript
// 「伏兵の射程内の城娘の攻撃が120上昇」の例

{
  id: 'ambush-buff-001',
  stat: 'attack',
  target: 'range',  // 範囲バフではあるが...
  mode: 'flat_sum',
  value: 120,
  
  // 動的バフとして扱う
  isDynamic: true,
  dynamicType: 'per_ambush_deployed',
  dynamicCategory: 'formation',  // 編成依存だが配置にも依存
  
  source: 'self_skill',
  note: '伏兵の射程内、配置位置と伏兵の種類に依存',
  
  // 伏兵依存フラグ
  requiresAmbush: true,  // ★新しいフラグ
  
  isActive: true
}
```

**新しいフィールド：requiresAmbush**:

伏兵依存のバフを明示的に識別するため、新しいフラグを導入します。

```typescript
interface Buff {
  // ... 既存のフィールド
  
  requiresAmbush?: boolean;  // 伏兵が配置されている必要があるバフ
}
```

このフラグが付いたバフは、UIで特別なマーキング（例：伏兵アイコン）を表示します。これにより、ユーザーは「このバフは伏兵が配置されている場合に有効」という重要な情報を視覚的に認識できます。

ただし、実際のゲームプレイにおいて、特に気管理を担当する支援型伏兵は高い信頼性を持つという実態も考慮する必要があります。そのため、将来的な拡張として、ユーザーが手動編集で伏兵バフの確信度を調整できるようにすることも検討できます。これにより、「この伏兵バフは死守するので信頼性が高い」とユーザーが判断した場合、バフパズルの主計算に含めることができます。

**バフパズルでの表示方針**:

範囲バフと伏兵バフの表示方法を整理します。通常の範囲バフ（超特大〜大、中〜小）は、バフマトリクスの通常セクションに表示します。ただし、noteに保存された範囲サイズ情報を視覚的に区別できるようにします。例えば、超特大は濃い色のバッジ、大は薄い色のバッジ、中は点線のバッジといった形で、範囲の信頼性を視覚化します。

一方、伏兵の射程内バフは、動的バフセクション（参考情報）に表示します。これは、ドレッドノートの伏兵バフと同じ扱いです。伏兵マーク（⚡や🔰などのアイコン）を付けることで、「このバフは伏兵依存です」という情報を明示します。

ただし、UIには「このバフを主計算に含める」といったオプションを用意することも検討できます。これにより、ユーザーが「この伏兵は死守するので信頼できる」と判断した場合、柔軟に対応できます。デフォルトでは動的バフとして扱いつつ、ユーザーの戦略に応じて調整可能という設計です。

この設計により、ツールは実態の複雑さを認識しつつ、デフォルトでは保守的な判断を提供し、必要に応じてユーザーがカスタマイズできるという柔軟性を持ちます。計略範囲バフは信頼できる情報として編成パズルに組み込み、伏兵バフはユーザーの戦略に応じて扱いを調整できる、という実用的な使い分けが可能になります。

**実装のポイント**:

パーサー実装時の注意点をまとめます。括弧内の情報抽出では、複数の情報が含まれる場合があります。例えば「(同種効果重複)(範囲：超特大、発動中の計略を解除しない)」のように、複数の括弧が連続したり、カンマで区切られたりします。正規表現で丁寧に分割し、それぞれの情報を適切に処理する必要があります。

範囲サイズが明示されていない計略もあります。その場合は、デフォルトでrangeとして扱うか、確信度を下げて処理します。パーサーは推測結果にconfidence: 'inferred'フラグを付け、ユーザーに確認を促します。

伏兵の射程内という表記は、「伏兵」というキーワードで検出できます。ただし、「伏兵を配置」といった召喚効果と区別する必要があります。文脈から「伏兵の射程内」というバフ範囲の指定だと判断できた場合のみ、requiresAmbushフラグを付けます。

**完全な検出パターン**:

計略範囲を検出する正規表現パターンを定義します。

```typescript
const STRATEGY_RANGE_PATTERNS = [
  {
    pattern: /範囲[：:]\s*(超特大|特大|大|中|小)/,
    extract: (match) => match[1],
    type: 'size'
  },
  {
    pattern: /伏兵の射程内/,
    extract: () => '伏兵の射程内',
    type: 'ambush_range',
    requiresAmbush: true
  },
  {
    pattern: /範囲内の(?:殿と)?城娘/,
    extract: () => 'default',
    type: 'default_range'
  }
];
```

これらのパターンを優先度順にチェックし、最初にマッチしたものを採用します。範囲サイズが検出できた場合は、変換テーブルに従ってtargetを決定します。伏兵の射程内が検出された場合は、isDynamic: trueとrequiresAmbush: trueを設定します。どちらも検出できなかった場合は、「範囲内の城娘」という一般的な表記からrangeと推測しますが、confidence: 'inferred'フラグを付けます。

このパターンは、計略バフの実態を反映しつつ、シンプルさを保った設計になっています。noteフィールドに詳細情報を保存することで、システムの複雑さを抑えながらも、必要な情報は失わない、という実用的なバランスを実現しています。

---

## 🔧 手動編集機能の必要性

パーサーがどれだけ優秀でも、城プロREのテキストの複雑さと多様性を考えると、100%完璧な解析は不可能です。むしろ、パーサーは80-90%の精度を目指し、残りは人間が修正できる仕組みを作る方が現実的です。

### 修正が必要になるケース

パーサーの解析結果を手動で修正する必要があるケースは、大きく3つのカテゴリに分類できます。

**ケース1: 主語の省略と文脈判断**

城プロREのテキストでは、主語が省略されることが頻繁にあります。例えば、「最大化時、射程内敵1体毎に防御が12%ずつ上昇(効果重複)」という文では、「防御が」の主語が明示されていません。パーサーは文脈から「自身の防御」と推測しますが、実際には「射程内の城娘の防御」だった、というケースが起こり得ます。

このような場合、パーサーは推測結果に確信度フラグを付けることができます。そして、ユーザーは実際のゲームでの動作を確認し、必要に応じて修正します。

**ケース2: 複雑な条件の解釈**

一部のキャラクター（特に伏兵を召喚するキャラ）の特技は、対象が暗黙的な複雑な構造を持ちます。例えば、「飛行敵以外に狙われず攻撃しない伏兵(1体)。時間経過で射程が徐々に上昇(上限200)。気の自然増加量を大きく増加(重複時効果減少)。射程内敵の撃破気1増加(重複なし)」というテキストでは、どの効果が伏兵に適用され、どの効果がフィールド全体に適用されるのかを判断するのが困難です。

パーサーはヒューリスティックなルールで推測しますが、誤る可能性があります。ユーザーが手動で修正できることで、正確なデータを維持できます。

**ケース3: 新しいパターンの出現**

城プロREは継続的にアップデートされ、新しいキャラクターが追加されます。新しいキャラクターは、これまで見たことのないパターンのバフを持っている可能性があります。パーサーがこのような新パターンに対応していない場合、ユーザーが手動で入力する必要があります。

手動で修正されたデータは、パーサーの改善に役立てることができます。ユーザーの修正履歴を分析することで、パーサーが苦手とするパターンを特定し、将来のアップデートで対応できます。

### UI設計の方針

手動編集機能のUIは、直感的で使いやすいものである必要があります。旧ツールで「登録・編集専門の画面」を用意されていたというのは、まさにこの問題への実践的な解決策です。

新しいツールでも、同様のアプローチを採用すべきでしょう。具体的には、キャラクター編集画面で、パーサーが生成したBuffオブジェクトの各フィールドを、GUIで編集できるようにします。

編集画面のイメージとしては、以下のような要素が含まれます。まず、特技や計略のテキストを表示し、そこから生成されたバフのリストを表示します。各バフは、展開可能なカード形式で表示され、クリックすると詳細が表示されます。

詳細画面では、statをドロップダウンメニューで選択できます。targetも同様にドロップダウンで選択できます。valueは数値入力フィールドで編集できます。modeもドロップダウンで選択できます。conditionTagsはチェックボックスで選択できます。

さらに、「バフを追加」ボタンを用意し、パーサーが検出できなかったバフを手動で追加できるようにします。逆に、「バフを削除」ボタンで、誤って検出されたバフを削除できます。

### 確信度フラグの活用

パーサーが推測した結果には、確信度フラグを付けることができます。これにより、ユーザーは「このバフは推測なので確認が必要」ということを認識できます。

```typescript
interface Buff {
  // ... 既存のフィールド
  
  confidence?: 'certain' | 'inferred' | 'uncertain';  // 確信度
  inferenceReason?: string;  // 推測の理由
}
```

UI上では、確信度が低いバフには警告アイコンを表示します。例えば、⚠️マークが付いたバフは、ユーザーに確認を促します。ユーザーが確認して正しいと判断した場合、確信度を「certain」に変更できます。逆に、誤りを発見した場合は修正します。

このシステムにより、パーサーの限界を認めつつ、ユーザーとの協力で高品質なデータを維持できます。完璧なパーサーを目指すのではなく、人間との協働を前提とした実用的なツール設計が重要です。

---

## 🆕 発見された追加パターン（v1.1で追加）

実際のキャラクターデータを調査した結果、v1.0では未カバーだった重要なパターンが発見されました。これらは反復的な改善の一環として追加されます。

### パターン1: 特技の発動条件マーカー

【配置】や【水上】のような、特技の発動条件を示すマーカーが存在します。

```typescript
// 例: 【配置】敵撃破毎に自身の攻撃5%と70上昇(効果重複)
// 例: 【水上】自身の巨大化気を半減
```

**処理方法**: 
- 【配置】: 条件タグとして扱わず、デフォルトで適用される特技として扱う
- 【水上】: ConditionTag 'on_water' として扱い、備考として表示

### パターン2: 発動トリガー付きバフ

「敵撃破毎に」のような、発動トリガーが明記されているバフです。

```typescript
// 例: 敵撃破毎に自身の攻撃5%と70上昇(効果重複、20回まで)
```

**処理方法**:
- 編成パズルでは、最大スタック時の値を表示
- 「20回まで」→ 攻撃 5% × 20 = 100%、固定値 70 × 20 = 1400
- 新しいフィールド `stackable` と `maxStacks` を追加

### パターン3: 明示されない鼓舞

【鼓舞】マーカーがなくても、鼓舞として扱うべきパターンが存在します。

```typescript
// 例: 自身を除く射程内城娘に自身の攻撃の30%の値を加算
// → これは鼓舞
```

**検出パターン**:
```typescript
/自身の(攻撃|防御|射程)(?:の|が)(\d+)%(?:の値)?を(.+?)(?:に|へ)加算/
```

### パターン4: 除外条件（「自身を除く」）

範囲指定に「自身を除く」という除外条件が付く場合があります。

```typescript
// 例: 自身を除く射程内城娘
```

**処理方法**:
- target に新しいModifier 'exclude_self' を追加
- または、conditionTag 'exclude_self' として扱う

### パターン5: 直撃ボーナス

直撃ボーナスは特殊な表記があります。

```typescript
// パターンA: 上限固定
"直撃ボーナスが300%に上昇" → 最終的な値が300%になる

// パターンB: 加算
"直撃ボーナスが50%上昇" → 現在値に50%加算
```

**新しいStat**: `critical_bonus`

**新しいMode**: `absolute_set` （上限固定の場合）

### パターン6: 自己適用時の倍率

全体バフだが、自身に対してだけ倍率が異なる場合があります。

```typescript
// 例: 全城娘の攻撃が50上昇。自身に対しては効果1.5倍。
```

**処理方法**: 2つの別々のバフとして生成
- バフA: target='all'、value=50、conditionTags=['exclude_self']
- バフB: target='self'、value=75（50 × 1.5）

### パターン7: 「攻撃が○倍のダメージを与える」

これは「与えるダメージ」と同じ計算式ですが、表記が異なります。

```typescript
// 例: 武器攻撃が標的とその周囲に1.5倍のダメージを与える
// → stat: 'give_damage', value: 50 (1.5倍 → 50%)
```

**検出パターン**:
```typescript
/(\d+(?:\.\d+)?)倍のダメージを与える/
```

### パターン8: 「同種効果と重複」

**重要**: これは「効果重複」の別表記です。意味は同じです。

```typescript
// 例: 攻撃と防御1.2倍(同種効果と重複)
// → これは「効果重複」と同じ意味
```

**表記のバリエーション**:
- 「効果重複」
- 「重複可」
- 「重複可能」
- 「同種効果と重複」← これも同じ意味

**処理方法**: 全て`isDuplicate: true`として扱います。新しいフラグは不要です。

### パターン9: 効果の上限回数

バフが重複する最大回数が明記されている場合があります。

```typescript
// 例: 攻撃5%上昇(効果重複、20回まで)
```

**新しいフィールド**:
```typescript
interface Buff {
  // ... 既存のフィールド
  maxStacks?: number;  // 最大スタック回数
  stackable?: boolean;  // スタック可能かどうか
}
```

### パターン10: HP/耐久依存条件

**重要**: 「HP」と「耐久」は同じ意味です。城プロREでは城娘の体力を「耐久」と呼びます。

条件が「HPが高いほど」「耐久が高いほど」のように、数値に依存する場合があります。これらは表記が異なるだけで、同じ条件として扱います。

```typescript
// 例1: 対象の耐久が高い程与えるダメージ上昇(最大2倍)
// 例2: HPが高い程攻撃上昇(最大1.5倍)
// → どちらも同じConditionTag: 'hp_dependent'
```

**新しいConditionTag**:
- `hp_dependent`: HP/耐久依存（数値が高いほど効果大）

**注意**: これは既存の`hp_above_50`などとは異なります。`hp_above_50`は「50%以上か未満か」という二値判定ですが、`hp_dependent`は「高ければ高いほど効果が大きい」という連続的な条件です。

**処理方法**: 最大値を記録し、備考として詳細を保持します。

```typescript
{
  stat: 'give_damage',
  target: 'self',
  mode: 'percent_max',
  value: 100,  // 最大2倍 → 100%
  conditionTags: ['hp_dependent'],
  note: 'HP/耐久が高いほど効果大（最大2倍）',
  source: 'strategy'
}
```

### パターン11: 爆風範囲・爆風ダメージ

ダメージ計算では無視してよいが、存在は認識すべきパターンです。

```typescript
// 例: 爆風範囲と爆風ダメージ2倍
```

**処理方法**: 備考（note）として記録し、パースはスキップ

