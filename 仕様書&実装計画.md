ShiroPro Tools (Reborn) 仕様書 & 実装計画
プロジェクト概要
城プロREの「編成作成」「バフ状況の可視化」「簡易ダメージ計算」を行うWebアプリケーション。 既存のプロジェクトから得た学びを活かし、React + TypeScript で堅牢かつ拡張性の高いシステムとして再構築する。

ユーザー体験 (UX) のゴール
一目でわかる: 編成の強み・弱点（不足しているバフ）が視覚的に即座に理解できる。
サクサク動く: Wikiからのデータ取り込みから編成、計算までがストレスなく行える。
パズルの楽しさ: キャラを入れ替えてバフの穴が埋まっていく快感を提供する。
技術スタック
Framework: React 18+
Language: TypeScript
Build Tool: Vite
Styling: TailwindCSS (v4)
State Management: React Context + useReducer (or Zustand)
Testing: Vitest
機能要件 & UI設計
1. 全体レイアウト (Single Page Application)
画面を大きく3つのセクションに分割するが、スクロールなしで主要情報が見える密度を目指す。

A. ヘッダー & 編成エリア (Formation)
8つのキャラ枠:
画像の代わりに「キャラ名」を表示。
視認性向上: 背景色で「属性（平/平山/水/山/地獄）」を表現。アイコンで「武器種」を表示。
ドラッグ&ドロップでの入れ替え（将来的な拡張、まずはクリックで選択→入れ替え）。
マップ制約設定 (Map Constraints):
「山城3体まで」「遠隔2体まで」などの制限を設定できる小さなメニュー。
制約違反時は、該当するキャラ枠を赤くハイライトして警告。
Wikiインポートボタン:
画面の隅（フッターまたはヘッダーの端）に配置。普段は邪魔にならないように。
B. バフ・マトリックス (Buff Matrix) - メインビュー
「数値の羅列」ではなく「パズル盤面」として直感的に理解できるUIを目指す。

1. セル表示: スタックバー & 2段レイアウト

上段 (状態): ● ◯ ● のように、誰からバフを受けているかをドットで簡易表示。
下段 (量): スタックバーで内訳を可視化。
青: 自己特技 / 緑: 味方特技 / 紫: 計略・鼓舞
例: [■■□□] 30% (自前20% + 味方10%)
2. 行サマリー: リファレンスゲージ 行の右端に「理想値」との比較ゲージを表示。

ゾーン表示: 赤(不足) → 緑(適正) → 青(過剰/Overcap)
警告: 基準を下回る行には ⚠ 不足 バッジを表示。
3. グルーピング & モード切替

カテゴリ: 「基本(攻/防/射)」「サブ(短縮/気)」「その他」で折り畳み可能に。
表示モード:
パズルモード: ドットと警告アイコン中心。
ガチ勢モード: 詳細数値とスタックバーをフル表示。
C. アタッカー分析ビュー (Attacker Analysis) - 別画面/ルート
編成画面とは別に、アタッカーの比較・分析に特化した専用画面。

1. バフ積み上げバー (Buff Stack) 最終攻撃力を構成する要素を積み上げグラフで表示。 [ 基礎 ] [ 自前 ] [ 編成 ] [ 鼓舞 ] [ 仮想(What-if) ] → 「この子は自前バフだけで戦える」「ここは編成バフ依存度が高い」などの構造を可視化。

2. 総合プロファイル (Radar Chart) 単純なDPSだけでなく、キャラの性質を多角的に評価。

軸: 有効DPS / 射程 / 手数(攻撃速度) / コスト効率 / 自己完結度
3. DPS vs 射程 散布図 (Scatter Plot)

X軸: 射程 / Y軸: DPS
「長射程・高火力」や「短射程・ロマン砲」などの立ち位置をプロットで可視化。
4. 仮想バフシミュレーション (What-If)

「もし攻撃+30%があったら？」をワンクリックで試せる機能。
積み上げバーの最上部に「半透明のブロック」として追加され、伸び幅を可視化。
データ構造 (TypeScript Interface)
Core Types
type Stat = 'attack' | 'defense' | 'range' | 'cooldown' | 'cost' | 'damage_dealt' | 'damage_taken';
type BuffMode = 'percent_max' | 'flat_sum'; // 最大値適用 or 合算
type ConditionTag = 'melee' | 'ranged' | 'water' | 'mountain' | 'flat' | 'hell' | 'hp_below_50' | 'strategy_active';
interface Buff {
  id: string;
  stat: Stat;
  mode: BuffMode;
  value: number;
  source: 'self_skill' | 'ally_skill' | 'strategy' | 'formation_skill';
  target: 'self' | 'range' | 'all';
  conditionTags?: ConditionTag[]; // 条件タグ
  isActive: boolean;
}
interface Character {
  id: string;
  name: string;
  weapon: string;
  attributes: string[]; // 平, 水, etc.
  baseStats: Record<Stat, number>; // 基礎ステータス
  skills: Buff[];
  strategies: Buff[];
}
interface Formation {
  slots: (Character | null)[]; // 8枠
}
Architecture Strategy
Core/UI Separation:
src/core/: 計算ロジック、データモデル、Wiki解析（純粋関数）。React依存なし。
src/ui/: 表示コンポーネント。Coreの結果を表示するだけ。
State Management:
Global: CharacterDB, Formation, MapConstraints
Local: UI state (modal open/close, input values)
Wiki Import Layers:
Fetcher (HTML取得) -> RawParser (テキスト抽出) -> Analyzer (正規化/Buff変換)
実装ステップ (Revised)
Phase 1: プロジェクト初期化 & Core基盤
Vite + React + TS でプロジェクト作成。
Type Definitions: Stat, BuffMode, ConditionTag などの型定義を固める。
Core Logic (TDD):
calcBuffMatrix(formation): 純粋関数として実装。
isBuffApplicable(buff, char): 条件判定ロジック。
Basic UI: 手入力データで動く最小限の編成画面とマトリックス表示。
この時点で計算ロジックの正しさを検証する。
Phase 2: Wikiインポート機能 (3層構造)
Fetcher: HTML取得。
RawParser: HTML → RawData (テキスト抽出)。
Analyzer: RawData → Character (正規表現でバフ解析)。
ここを重点的にテストする。
Integration: UIにインポート機能を組み込み、Coreロジックと接続。
Phase 3: UI/UXの深化 (バフ・マトリックス & アタッカー分析)
Rich Matrix UI: スタックバー、リファレンスゲージ、モード切替の実装。
Attacker Analysis:
積み上げバー、レーダーチャート、散布図の実装。
What-Ifシミュレーション機能。
Phase 4: 仕上げ & 共有機能
Serialization: serializeState / deserializeState の実装（URL共有/LocalStorage用）。
Map Constraints: プリセット機能付きの制約設定。
Onboarding: 初回ユーザー向けのガイドやサンプルデータロード。